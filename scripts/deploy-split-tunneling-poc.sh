#!/bin/bash

##############################################################################
# WireGuard Split Tunneling - Quick PoC Deployment Script
# 
# 用途: 快速部署分流功能概念验证（无需修改 wg-easy 代码）
# 作者: wg-easy Split Tunneling Project
# 版本: 1.0.0
# 日期: 2025-10-02
#
# 使用方法:
#   ./deploy-split-tunneling-poc.sh <client_ip> <upstream_endpoint> <upstream_pubkey> [domain]
#
# 示例:
#   ./deploy-split-tunneling-poc.sh 10.8.0.2 us.example.com:51820 xxx google.com
##############################################################################

set -e

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Banner
cat <<'EOF'
╔══════════════════════════════════════════════════════════════╗
║                                                              ║
║     WireGuard Split Tunneling - PoC Deployment              ║
║                                                              ║
║     Version: 1.0.0                                           ║
║     Project: wg-easy Split Tunneling                         ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝
EOF
echo ""

# 参数解析
CLIENT_IP="${1}"
UPSTREAM_ENDPOINT="${2}"
UPSTREAM_PUBLIC_KEY="${3}"
SPLIT_DOMAIN="${4:-google.com}"

if [ -z "$CLIENT_IP" ] || [ -z "$UPSTREAM_ENDPOINT" ] || [ -z "$UPSTREAM_PUBLIC_KEY" ]; then
  log_error "Missing required parameters"
  echo ""
  echo "Usage: $0 <client_ip> <upstream_endpoint> <upstream_public_key> [split_domain]"
  echo ""
  echo "Parameters:"
  echo "  client_ip          - WireGuard client IP (e.g., 10.8.0.2)"
  echo "  upstream_endpoint  - Upstream WG server endpoint (e.g., us.example.com:51820)"
  echo "  upstream_public_key- Upstream server public key"
  echo "  split_domain       - Domain to route through proxy (default: google.com)"
  echo ""
  echo "Example:"
  echo "  $0 10.8.0.2 us.example.com:51820 abcd1234...xyz google.com"
  exit 1
fi

# 配置变量
CLIENT_ID=1
IPSET_NAME="client_${CLIENT_ID}_proxy"
FWMARK=$((100 + CLIENT_ID))
ROUTE_TABLE=$((100 + CLIENT_ID))
UPSTREAM_IFACE="wg-up-1"

# 显示配置
log_info "Configuration:"
echo "  Client IP:       ${CLIENT_IP}"
echo "  Client ID:       ${CLIENT_ID}"
echo "  Upstream:        ${UPSTREAM_ENDPOINT}"
echo "  Upstream Iface:  ${UPSTREAM_IFACE}"
echo "  Split Domain:    ${SPLIT_DOMAIN}"
echo "  IPSet Name:      ${IPSET_NAME}"
echo "  Firewall Mark:   ${FWMARK}"
echo "  Route Table:     ${ROUTE_TABLE}"
echo ""

read -p "Continue with deployment? (y/n) " -n 1 -r
echo ""
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
  log_warning "Deployment cancelled by user"
  exit 0
fi

##############################################################################
# Step 1: 检查依赖
##############################################################################
log_info "Step 1: Checking dependencies..."

check_command() {
  if command -v $1 >/dev/null 2>&1; then
    log_success "$1 is installed"
    return 0
  else
    log_warning "$1 is not installed"
    return 1
  fi
}

MISSING_DEPS=0
check_command wg || MISSING_DEPS=1
check_command dnsmasq || MISSING_DEPS=1
check_command ipset || MISSING_DEPS=1
check_command iptables || MISSING_DEPS=1
check_command ip || MISSING_DEPS=1

if [ $MISSING_DEPS -eq 1 ]; then
  log_info "Installing missing dependencies..."
  apk add --no-cache dnsmasq ipset iproute2 wireguard-tools 2>/dev/null || {
    log_error "Failed to install dependencies"
    exit 1
  }
  log_success "Dependencies installed"
fi

##############################################################################
# Step 2: 生成密钥
##############################################################################
log_info "Step 2: Generating WireGuard keys..."

PRIVATE_KEY=$(wg genkey)
PUBLIC_KEY=$(echo ${PRIVATE_KEY} | wg pubkey)

log_success "Keys generated:"
echo "  Local Private Key: ${PRIVATE_KEY:0:10}...${PRIVATE_KEY: -10}"
echo "  Local Public Key:  ${PUBLIC_KEY}"
echo ""
log_warning "IMPORTANT: Add this public key to your upstream server:"
echo "  ${PUBLIC_KEY}"
echo ""

##############################################################################
# Step 3: 创建上游 WireGuard 接口
##############################################################################
log_info "Step 3: Creating upstream WireGuard interface..."

cat > /etc/wireguard/${UPSTREAM_IFACE}.conf <<EOF
# Auto-generated by split-tunneling deployment script
# Upstream WireGuard Interface
# Generated: $(date)

[Interface]
PrivateKey = ${PRIVATE_KEY}
MTU = 1360

[Peer]
PublicKey = ${UPSTREAM_PUBLIC_KEY}
Endpoint = ${UPSTREAM_ENDPOINT}
AllowedIPs = 0.0.0.0/0
PersistentKeepalive = 25
EOF

log_success "Configuration file created: /etc/wireguard/${UPSTREAM_IFACE}.conf"

# 停止旧接口（如果存在）
wg-quick down ${UPSTREAM_IFACE} 2>/dev/null || true

# 启动接口
log_info "Starting ${UPSTREAM_IFACE}..."
if wg-quick up ${UPSTREAM_IFACE}; then
  log_success "Upstream interface ${UPSTREAM_IFACE} started"
else
  log_error "Failed to start upstream interface"
  exit 1
fi

# 验证接口
sleep 2
if ip link show ${UPSTREAM_IFACE} >/dev/null 2>&1; then
  log_success "Interface ${UPSTREAM_IFACE} is up"
else
  log_error "Interface ${UPSTREAM_IFACE} not found"
  exit 1
fi

##############################################################################
# Step 4: 创建 ipset
##############################################################################
log_info "Step 4: Creating ipset ${IPSET_NAME}..."

# 删除旧 ipset（如果存在）
ipset destroy ${IPSET_NAME} 2>/dev/null || true

# 创建新 ipset
if ipset create ${IPSET_NAME} hash:ip timeout 3600; then
  log_success "IPSet ${IPSET_NAME} created"
else
  log_error "Failed to create ipset"
  exit 1
fi

##############################################################################
# Step 5: 配置 iptables 标记
##############################################################################
log_info "Step 5: Configuring iptables rules..."

# 删除旧规则（如果存在）
iptables -t mangle -D PREROUTING \
  -s ${CLIENT_IP} \
  -m set --match-set ${IPSET_NAME} dst \
  -j MARK --set-mark ${FWMARK} \
  2>/dev/null || true

# 添加新规则
if iptables -t mangle -A PREROUTING \
  -s ${CLIENT_IP} \
  -m set --match-set ${IPSET_NAME} dst \
  -j MARK --set-mark ${FWMARK} \
  -m comment --comment "wg-easy-split-client-${CLIENT_ID}"; then
  log_success "iptables rule added"
else
  log_error "Failed to add iptables rule"
  exit 1
fi

##############################################################################
# Step 6: 配置策略路由
##############################################################################
log_info "Step 6: Configuring policy routing..."

# 添加路由表定义
if ! grep -q "^${ROUTE_TABLE}" /etc/iproute2/rt_tables; then
  echo "${ROUTE_TABLE} client_${CLIENT_ID}" >> /etc/iproute2/rt_tables
  log_success "Route table ${ROUTE_TABLE} added to rt_tables"
fi

# 删除旧规则
ip rule del fwmark ${FWMARK} table ${ROUTE_TABLE} 2>/dev/null || true
ip route flush table ${ROUTE_TABLE} 2>/dev/null || true

# 添加策略路由规则
if ip rule add fwmark ${FWMARK} table ${ROUTE_TABLE} prio $((1000 + CLIENT_ID)); then
  log_success "Policy routing rule added (fwmark ${FWMARK} → table ${ROUTE_TABLE})"
else
  log_error "Failed to add policy routing rule"
  exit 1
fi

# 添加默认路由
if ip route add default dev ${UPSTREAM_IFACE} table ${ROUTE_TABLE}; then
  log_success "Default route added to table ${ROUTE_TABLE}"
else
  log_error "Failed to add default route"
  exit 1
fi

##############################################################################
# Step 7: 配置 dnsmasq
##############################################################################
log_info "Step 7: Configuring dnsmasq..."

# 创建配置目录
mkdir -p /etc/dnsmasq.d

# 创建主配置（如果不存在）
if [ ! -f /etc/dnsmasq.conf ]; then
  cat > /etc/dnsmasq.conf <<'EOF'
# dnsmasq configuration for wg-easy split tunneling
no-resolv
server=1.1.1.1
server=8.8.8.8
cache-size=1000
conf-dir=/etc/dnsmasq.d/,*.conf

# Optional: Enable query logging
# log-queries
# log-facility=/var/log/dnsmasq.log
EOF
  log_success "dnsmasq.conf created"
fi

# 创建分流配置
cat > /etc/dnsmasq.d/split-tunneling.conf <<EOF
# Auto-generated split tunneling configuration
# Generated: $(date)
# Client ID: ${CLIENT_ID}
# Client IP: ${CLIENT_IP}

# Domain rules
ipset=/${SPLIT_DOMAIN}/${IPSET_NAME}
ipset=/www.${SPLIT_DOMAIN}/${IPSET_NAME}
EOF

log_success "Split tunneling config created"

# 启动或重载 dnsmasq
if pgrep dnsmasq >/dev/null; then
  log_info "Reloading dnsmasq..."
  killall -HUP dnsmasq
  log_success "dnsmasq reloaded"
else
  log_info "Starting dnsmasq..."
  if dnsmasq; then
    log_success "dnsmasq started"
  else
    log_error "Failed to start dnsmasq"
    exit 1
  fi
fi

##############################################################################
# Step 8: 验证配置
##############################################################################
log_info "Step 8: Verifying configuration..."

sleep 2

# 8.1 检查上游接口
if wg show ${UPSTREAM_IFACE} >/dev/null 2>&1; then
  log_success "Upstream interface is active"
  wg show ${UPSTREAM_IFACE} | head -n 5
else
  log_error "Upstream interface verification failed"
  exit 1
fi

echo ""

# 8.2 测试 DNS 解析
log_info "Testing DNS resolution for ${SPLIT_DOMAIN}..."
TEST_IP=$(dig @127.0.0.1 ${SPLIT_DOMAIN} +short 2>/dev/null | head -n1)

if [ -n "$TEST_IP" ]; then
  log_success "DNS resolved: ${SPLIT_DOMAIN} → ${TEST_IP}"
  
  # 等待 ipset 更新
  sleep 2
  
  # 8.3 检查 ipset
  if ipset test ${IPSET_NAME} ${TEST_IP} 2>/dev/null; then
    log_success "IP ${TEST_IP} successfully added to ipset"
  else
    log_warning "IP not yet in ipset (may take a moment)"
    log_info "Manually adding test IP..."
    ipset add ${IPSET_NAME} ${TEST_IP} 2>/dev/null || true
  fi
else
  log_warning "DNS resolution returned no result"
fi

echo ""

# 8.4 检查 iptables 规则
if iptables -t mangle -S PREROUTING | grep -q "wg-easy-split-client-${CLIENT_ID}"; then
  log_success "iptables rules configured"
else
  log_error "iptables rules not found"
fi

# 8.5 检查策略路由
if ip rule list | grep -q "fwmark 0x$(printf '%x' ${FWMARK})"; then
  log_success "Policy routing rules configured"
else
  log_error "Policy routing rules not found"
fi

# 8.6 检查路由表
ROUTE_COUNT=$(ip route show table ${ROUTE_TABLE} | wc -l)
if [ $ROUTE_COUNT -gt 0 ]; then
  log_success "Routing table ${ROUTE_TABLE} has ${ROUTE_COUNT} route(s)"
else
  log_warning "Routing table is empty"
fi

##############################################################################
# Step 9: 生成测试和管理脚本
##############################################################################
log_info "Step 9: Generating helper scripts..."

# 9.1 测试脚本
cat > /tmp/test-split-tunneling.sh <<TESTEOF
#!/bin/bash
# Quick test script

echo "=== Testing Split Tunneling ==="
echo ""

echo "1. Testing DNS resolution..."
dig @127.0.0.1 ${SPLIT_DOMAIN} +short

echo ""
echo "2. IPSet contents:"
ipset list ${IPSET_NAME} | grep -E '^[0-9]|Number of entries'

echo ""
echo "3. iptables counters:"
iptables -t mangle -L PREROUTING -n -v | grep wg-easy-split

echo ""
echo "4. Routing decision for ${SPLIT_DOMAIN}:"
if [ -n "${TEST_IP}" ]; then
  ip route get ${TEST_IP} from ${CLIENT_IP} 2>/dev/null || echo "Route lookup failed"
fi

echo ""
echo "5. Upstream interface status:"
wg show ${UPSTREAM_IFACE}

echo ""
echo "=== Test Complete ==="
TESTEOF

chmod +x /tmp/test-split-tunneling.sh

# 9.2 清理脚本
cat > /tmp/cleanup-split-tunneling.sh <<CLEANEOF
#!/bin/bash
# Cleanup script

echo "Cleaning up split tunneling configuration..."

# Stop upstream interface
wg-quick down ${UPSTREAM_IFACE} 2>/dev/null || true
echo "✓ Stopped ${UPSTREAM_IFACE}"

# Delete iptables rules
iptables -t mangle -D PREROUTING \
  -s ${CLIENT_IP} \
  -m set --match-set ${IPSET_NAME} dst \
  -j MARK --set-mark ${FWMARK} 2>/dev/null || true
echo "✓ Removed iptables rules"

# Delete policy routing
ip rule del fwmark ${FWMARK} table ${ROUTE_TABLE} 2>/dev/null || true
ip route flush table ${ROUTE_TABLE} 2>/dev/null || true
echo "✓ Removed policy routing"

# Destroy ipset
ipset destroy ${IPSET_NAME} 2>/dev/null || true
echo "✓ Destroyed ipset"

# Clean dnsmasq config
rm -f /etc/dnsmasq.d/split-tunneling.conf
killall -HUP dnsmasq 2>/dev/null || true
echo "✓ Cleaned dnsmasq config"

echo ""
echo "Cleanup complete!"
CLEANEOF

chmod +x /tmp/cleanup-split-tunneling.sh

log_success "Helper scripts created:"
echo "  Test:    /tmp/test-split-tunneling.sh"
echo "  Cleanup: /tmp/cleanup-split-tunneling.sh"

##############################################################################
# 完成
##############################################################################
echo ""
echo "╔══════════════════════════════════════════════════════════════╗"
echo "║                 Deployment Complete! ✓                       ║"
echo "╚══════════════════════════════════════════════════════════════╝"
echo ""

log_success "Split tunneling is now configured for client ${CLIENT_IP}"
echo ""

cat <<'NEXTEOF'
┌─────────────────────────────────────────────────────────────┐
│  Next Steps:                                                 │
└─────────────────────────────────────────────────────────────┘

1. Configure your WireGuard client:
   
   [Interface]
   Address = 10.8.0.2/24
   PrivateKey = <your_client_private_key>
   DNS = 10.8.0.1          ← IMPORTANT: Use wg-easy DNS
   
   [Peer]
   PublicKey = <wg-easy_server_public_key>
   Endpoint = <wg-easy_server>:51820
   AllowedIPs = 0.0.0.0/0

2. Connect the WireGuard client:
   
   $ wg-quick up client

3. Test the split tunneling:
   
   # Should show LOCAL IP (direct connection)
   $ curl ipinfo.io/ip
   
   # Should show UPSTREAM IP (proxied through wg-up-1)
   $ curl --resolve google.com:443:<IP_from_DNS> https://google.com/search?q=my+ip

4. Verify on server:
   
   $ /tmp/test-split-tunneling.sh

5. Monitor traffic:
   
   # Watch ipset changes
   $ watch -n 1 'ipset list client_1_proxy'
   
   # Watch upstream traffic
   $ watch -n 1 'wg show wg-up-1'

6. Cleanup when done:
   
   $ /tmp/cleanup-split-tunneling.sh

┌─────────────────────────────────────────────────────────────┐
│  Troubleshooting:                                            │
└─────────────────────────────────────────────────────────────┘

If split tunneling doesn't work:

1. Check DNS resolution:
   $ dig @127.0.0.1 google.com
   
2. Check if IP is in ipset:
   $ ipset list client_1_proxy
   
3. Manually add test IP:
   $ ipset add client_1_proxy 8.8.8.8
   $ ping 8.8.8.8  # from client
   
4. Check routing:
   $ ip route get 8.8.8.8 from 10.8.0.2
   
5. Check upstream handshake:
   $ wg show wg-up-1 | grep handshake
   
6. View logs:
   $ tail -f /var/log/dnsmasq.log  # if enabled

┌─────────────────────────────────────────────────────────────┐
│  Configuration Details:                                      │
└─────────────────────────────────────────────────────────────┘
NEXTEOF

echo "WireGuard Config:  /etc/wireguard/${UPSTREAM_IFACE}.conf"
echo "dnsmasq Config:    /etc/dnsmasq.d/split-tunneling.conf"
echo "IPSet Name:        ${IPSET_NAME}"
echo "Route Table:       ${ROUTE_TABLE}"
echo ""

cat <<'DOCSEOF'
┌─────────────────────────────────────────────────────────────┐
│  Documentation:                                              │
└─────────────────────────────────────────────────────────────┘

For more information, see:
  - MINIMAL_WORKING_EXAMPLE.md  - Detailed manual steps
  - QUICK_START_GUIDE.md        - Complete implementation guide
  - ARCHITECTURE_DESIGN.md      - Architecture details

For issues or questions:
  - GitHub: https://github.com/wg-easy/wg-easy/issues
  - Docs: https://wg-easy.github.io/wg-easy/

DOCSEOF

log_info "Deployment script finished successfully"
exit 0
